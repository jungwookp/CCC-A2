// geohash.js
// Geohash library for Javascript
// (c) 2008 David Troy\n// Distributed under the MIT License
BITS = [ 16, 8, 4, 2, 1 ];
BASE32 = "0123456789bcdefghjkmnpqrstuvwxyz";
NEIGHBORS = {\n  right : {\n    even : \"bc01fg45238967deuvhjyznpkmstqrwx\"\n  },\n  left : {\n    even : \"238967debc01fg45kmstqrwxuvhjyznp\"\n  },\n  top : {\n    even : \"p0r21436x8zb9dcf5h7kjnmqesgutwvy\"\n  },\n  bottom : {\n    even : \"14365h7k9dcfesgujnmqp0r2twvyx8zb\"\n  }\n};\nBORDERS = {\n  right : {\n    even : \"bcfguvyz\"\n  },\n  left : {\n    even : \"0145hjnp\"\n  },\n  top : {\n    even : \"prxz\"\n  },\n  bottom : {\n    even : \"028b\"\n  }\n};\n\nNEIGHBORS.bottom.odd = NEIGHBORS.left.even;\nNEIGHBORS.top.odd = NEIGHBORS.right.even;\nNEIGHBORS.left.odd = NEIGHBORS.bottom.even;\nNEIGHBORS.right.odd = NEIGHBORS.top.even;\n\nBORDERS.bottom.odd = BORDERS.left.even;\nBORDERS.top.odd = BORDERS.right.even;\nBORDERS.left.odd = BORDERS.bottom.even;\nBORDERS.right.odd = BORDERS.top.even;\n\nexports.refine_interval = function(interval, cd, mask) {\n  if (cd & mask)\n    interval[0] = (interval[0] + interval[1]) / 2;\n  else\n    interval[1] = (interval[0] + interval[1]) / 2;\n}\n\nexports.calculateAdjacent = function(srcHash, dir) {\n  srcHash = srcHash.toLowerCase();\n  var lastChr = srcHash.charAt(srcHash.length - 1);\n  var type = (srcHash.length % 2) ? 'odd' : 'even';\n  var base = srcHash.substring(0, srcHash.length - 1);\n  if (BORDERS[dir][type].indexOf(lastChr) != -1)\n    base = calculateAdjacent(base, dir);\n  return base + BASE32[NEIGHBORS[dir][type].indexOf(lastChr)];\n}\n\nexports.decodeGeoHash = function(geohash) {\n  var is_even = 1;\n  var lat = [];\n  var lon = [];\n  lat[0] = -90.0;\n  lat[1] = 90.0;\n  lon[0] = -180.0;\n  lon[1] = 180.0;\n  lat_err = 90.0;\n  lon_err = 180.0;\n\n  for (i = 0; i < geohash.length; i++) {\n    c = geohash[i];\n    cd = BASE32.indexOf(c);\n    for (j = 0; j < 5; j++) {\n      mask = BITS[j];\n      if (is_even) {\n        lon_err /= 2;\n        refine_interval(lon, cd, mask);\n      } else {\n        lat_err /= 2;\n        refine_interval(lat, cd, mask);\n      }\n      is_even = !is_even;\n    }\n  }\n  lat[2] = (lat[0] + lat[1]) / 2;\n  lon[2] = (lon[0] + lon[1]) / 2;\n\n  return {\n    latitude : lat,\n    longitude : lon\n  };\n}\n\nexports.encodeGeoHash = function(latitude, longitude) {\n  var is_even = 1;\n  var i = 0;\n  var lat = [];\n  var lon = [];\n  var bit = 0;\n  var ch = 0;\n  var precision = 12;\n  geohash = \"\";\n\n  lat[0] = -90.0;\n  lat[1] = 90.0;\n  lon[0] = -180.0;\n  lon[1] = 180.0;\n\n  while (geohash.length < precision) {\n    if (is_even) {\n      mid = (lon[0] + lon[1]) / 2;\n      if (longitude > mid) {\n        ch |= BITS[bit];\n        lon[0] = mid;\n      } else\n        lon[1] = mid;\n    } else {\n      mid = (lat[0] + lat[1]) / 2;\n      if (latitude > mid) {\n        ch |= BITS[bit];\n        lat[0] = mid;\n      } else\n        lat[1] = mid;\n    }\n\n    is_even = !is_even;\n    if (bit < 4)\n      bit++;\n    else {\n      geohash += BASE32[ch];\n      bit = 0;\n      ch = 0;\n    }\n  }\n  return geohash;\n}